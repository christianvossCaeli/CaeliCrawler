<template>
  <div>
    <!-- Loading State -->
    <v-overlay :model-value="loading" class="align-center justify-center" persistent >
      <v-card class="pa-8 text-center" min-width="320" elevation="24">
        <v-progress-circular indeterminate size="80" width="6" color="primary" class="mb-4"></v-progress-circular>
        <div class="text-h6 mb-2">{{ t('entityDetail.loading') }}</div>
      </v-card>
    </v-overlay>

    <!-- Breadcrumbs -->
    <v-breadcrumbs :items="breadcrumbs" class="px-0">
      <template v-slot:prepend>
        <v-icon icon="mdi-home" size="small"></v-icon>
      </template>
    </v-breadcrumbs>

    <!-- Entity Header -->
    <EntityDetailHeader
      v-if="entity"
      :entity="entity"
      :entity-type="entityType"
      :facet-groups="facetsSummary?.facets_by_type || []"
      :notes-count="notes.length"
      :verified-count="facetsSummary?.verified_count || 0"
      :data-sources-count="dataSources.length"
      :children-count="childrenCount"
      @open-notes="notesDialog = true"
      @open-export="exportDialog = true"
      @open-edit="editDialog = true"
      @add-facet="addFacetDialog = true"
      @add-facet-value="openAddFacetValueDialog"
    />

    <!-- Tabs for Content -->
    <v-tabs v-model="activeTab" color="primary" class="mb-4">
      <v-tab value="facets">
        <v-icon start>mdi-tag-multiple</v-icon>
        {{ t('entityDetail.tabs.properties') }}
        <v-chip v-if="facetsSummary" size="x-small" class="ml-2">{{ facetsSummary.total_facet_values }}</v-chip>
      </v-tab>
      <v-tab value="connections">
        <v-icon start>mdi-sitemap</v-icon>
        {{ t('entityDetail.tabs.connections', 'Verkn√ºpfungen') }}
        <v-chip v-if="totalConnectionsCount" size="x-small" class="ml-2">{{ totalConnectionsCount }}</v-chip>
      </v-tab>
      <v-tab value="sources">
        <v-icon start>mdi-web</v-icon>
        {{ t('entityDetail.tabs.dataSources') }}
        <v-chip v-if="dataSources.length" size="x-small" class="ml-2">{{ dataSources.length }}</v-chip>
      </v-tab>
      <v-tab value="documents">
        <v-icon start>mdi-file-document-multiple</v-icon>
        {{ t('entityDetail.tabs.documents') }}
      </v-tab>
      <v-tab v-if="entityType?.supports_pysis" value="pysis">
        <v-icon start>mdi-database-sync</v-icon>
        {{ t('entityDetail.tabs.pysis') }}
      </v-tab>
      <v-tab v-if="externalData?.has_external_data" value="api-data">
        <v-icon start>mdi-code-json</v-icon>
        {{ t('entityDetail.tabs.apiData', 'API-Daten') }}
      </v-tab>
      <v-tab value="attachments">
        <v-icon start>mdi-paperclip</v-icon>
        {{ t('entityDetail.tabs.attachments') }}
        <v-chip v-if="attachmentCount" size="x-small" class="ml-2">{{ attachmentCount }}</v-chip>
      </v-tab>
    </v-tabs>

    <v-window v-model="activeTab">
      <!-- Facets Tab -->
      <v-window-item value="facets">
        <EntityFacetsTab
          :entity="entity"
          :entity-type="entityType"
          :facets-summary="facetsSummary"
          @facets-updated="refreshFacetsSummary"
          @add-facet="addFacetDialog = true"
          @add-facet-value="openAddFacetValueDialog"
          @switch-tab="activeTab = $event"
          @enrichment-started="onEnrichmentStarted"
        />
      </v-window-item>

      <!-- Relations Tab -->
      <v-window-item value="connections">
        <EntityConnectionsTab
          :entity="entity"
          :entity-type="entityType"
          :type-slug="typeSlug || ''"
          :relations="relations"
          :children="children"
          :children-count="childrenCount"
          :children-page="childrenPage"
          :children-total-pages="childrenTotalPages"
          :children-search-query="childrenSearchQuery"
          :loading-relations="loadingRelations"
          :loading-children="loadingChildren"
          :hierarchy-enabled="flags.entityHierarchyEnabled"
          @add-relation="openAddRelationDialog"
          @edit-relation="editRelation"
          @delete-relation="confirmDeleteRelation"
          @navigate-relation="navigateToRelatedEntity"
          @load-children="loadChildren"
          @update:children-page="childrenPage = $event"
          @update:children-search-query="childrenSearchQuery = $event"
        />
      </v-window-item>

      <!-- Data Sources Tab -->
      <v-window-item value="sources">
        <EntitySourcesTab
          :data-sources="dataSources"
          :loading="loadingDataSources"
          :starting-crawl-id="startingCrawl"
          @link-source="linkDataSourceDialog = true"
          @edit-source="openEditSourceDialog"
          @start-crawl="startCrawl"
          @unlink-source="confirmUnlinkSource"
          @delete-source="confirmDeleteSource"
        />
      </v-window-item>

      <!-- Documents Tab -->
      <v-window-item value="documents">
        <EntityDocumentsTab
          :documents="documents"
          :loading="loadingDocuments"
        />
      </v-window-item>

      <!-- PySis Tab (only for municipalities) -->
      <v-window-item v-if="entityType?.supports_pysis" value="pysis" eager>
        <PySisTab
          v-if="entity"
          :municipality="entity.name"
        />
      </v-window-item>

      <!-- External API Data Tab -->
      <v-window-item v-if="externalData?.has_external_data" value="api-data">
        <EntityApiDataTab :external-data="externalData" />
      </v-window-item>

      <!-- Attachments Tab -->
      <v-window-item value="attachments">
        <EntityAttachmentsTab
          v-if="entity"
          :entity-id="entity.id"
          @attachments-changed="loadAttachmentCount"
        />
      </v-window-item>

      <!-- Children Tab (Untergeordnete Entities) -->
    </v-window>

    <!-- Add Facet Dialog -->
    <AddFacetDialog
      v-model="addFacetDialog"
      :facet-type-id="newFacet.facet_type_id"
      :facet-types="applicableFacetTypes"
      :selected-facet-type="selectedFacetTypeForForm ?? null"
      :value="newFacet.value"
      :text-representation="newFacet.text_representation"
      :source-url="newFacet.source_url"
      :confidence-score="newFacet.confidence_score"
      :saving="savingFacet"
      @update:facet-type-id="onFacetTypeChange"
      @update:value="newFacet.value = $event"
      @update:text-representation="newFacet.text_representation = $event"
      @update:source-url="newFacet.source_url = $event"
      @update:confidence-score="newFacet.confidence_score = $event"
      @save="saveFacetValue"
      @close="closeAddFacetDialog"
    />

    <!-- Facet Details Dialog -->
    <FacetDetailsDialog
      v-model="facetDetailsDialog"
      :facet-group="selectedFacetGroup"
      :facet-values="facetDetails"
      @verify="verifyFacet"
      @copy-email="copyToClipboard"
    />

    <!-- Edit Entity Dialog -->
    <EntityEditDialog
      v-model="editDialog"
      :name="editForm.name"
      :external-id="editForm.external_id"
      :entity-type-name="entityType?.name"
      :saving="savingEntity"
      @update:name="editForm.name = $event"
      @update:external-id="editForm.external_id = $event"
      @save="saveEntity"
    />

    <!-- Bulk Delete Confirmation Dialog -->
    <!-- Bulk delete dialog moved to EntityFacetsTab.vue -->

    <!-- Single Facet Delete Confirmation Dialog -->
    <ConfirmDialog
      v-model="singleDeleteConfirm"
      :title="t('entityDetail.dialog.deleteFacets')"
      :message="t('entityDetail.dialog.deleteFacetsConfirm', { count: 1 })"
      :subtitle="t('entityDetail.dialog.cannotUndo')"
      :confirm-text="t('common.delete')"
      confirm-icon="mdi-delete"
      :loading="deletingFacet"
      @confirm="deleteSingleFacet"
    />

    <!-- Edit Facet Dialog -->
    <v-dialog v-model="editFacetDialog" max-width="800">
      <v-card>
        <v-card-title>
          <v-icon start>mdi-pencil</v-icon>
          {{ t('entityDetail.dialog.editFacet') }}
        </v-card-title>
        <v-card-text v-if="editingFacet">
          <DynamicSchemaForm
            v-if="editingFacetSchema"
            v-model="editingFacetValue"
            :schema="editingFacetSchema"
          />
          <v-textarea
            v-else
            v-model="editingFacetTextValue"
            :label="t('entities.facet.value')"
            rows="3"
            variant="outlined"
            class="mt-2"
          ></v-textarea>
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn variant="tonal" @click="editFacetDialog = false">{{ t('common.cancel') }}</v-btn>
          <v-btn variant="tonal" color="primary" :loading="savingFacet" @click="saveEditedFacet">
            {{ t('common.save') }}
          </v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

    <!-- Add/Edit Relation Dialog -->
    <AddRelationDialog
      v-model="addRelationDialog"
      :editing="!!editingRelation"
      :relation-type-id="newRelation.relation_type_id"
      :direction="newRelation.direction"
      :target-entity-id="newRelation.target_entity_id"
      :attributes-json="newRelation.attributes_json"
      :relation-types="relationTypes"
      :target-entities="targetEntities"
      :loading-relation-types="loadingRelationTypes"
      :searching-entities="searchingEntities"
      :search-query="entitySearchQuery"
      :saving="savingRelation"
      @update:relation-type-id="newRelation.relation_type_id = $event"
      @update:direction="newRelation.direction = $event"
      @update:target-entity-id="newRelation.target_entity_id = $event"
      @update:attributes-json="newRelation.attributes_json = $event"
      @save="saveRelation"
      @close="closeRelationDialog"
      @search="searchEntities"
    />

    <!-- Delete Relation Confirmation -->
    <ConfirmDialog
      v-model="deleteRelationConfirm"
      :title="t('entityDetail.dialog.deleteRelation')"
      :message="t('entityDetail.dialog.deleteRelationConfirm')"
      :subtitle="relationToDelete ? `${relationToDelete.relation_type_name}: ${relationToDelete.target_entity_name || relationToDelete.source_entity_name}` : undefined"
      :confirm-text="t('common.delete')"
      :loading="deletingRelation"
      @confirm="deleteRelation"
    />

    <!-- Export Dialog -->
    <EntityExportDialog
      v-model="exportDialog"
      :format="exportFormat"
      :options="exportOptions"
      :exporting="exporting"
      @update:format="exportFormat = $event"
      @update:options="exportOptions = $event"
      @export="exportData"
    />

    <!-- Link Data Source Dialog -->
    <LinkDataSourceDialog
      v-model="linkDataSourceDialog"
      :selected-source="selectedSourceToLink"
      :available-sources="availableSourcesForLink"
      :searching="searchingSourcesForLink"
      :search-query="sourceSearchQuery"
      :linking="linkingSource"
      @update:selected-source="selectedSourceToLink = $event"
      @search="searchSourcesForLink"
      @link="linkSourceToEntity"
      @create-new="goToSourcesWithEntity"
    />

    <!-- Data Source Management Dialogs -->
    <EntityDataSourceManager
      v-if="entity"
      :entity-id="entity.id"
      v-model:show-edit-dialog="editSourceDialog"
      v-model:show-delete-dialog="deleteSourceConfirm"
      v-model:show-unlink-dialog="unlinkSourceConfirm"
      :source-to-edit="editingSource"
      :source-to-delete="sourceToDelete"
      :source-to-unlink="sourceToUnlink"
      @source-updated="onSourceUpdated"
      @source-deleted="onSourceDeleted"
      @source-unlinked="onSourceUnlinked"
    />

    <!-- PySis Enrichment Dialogs -->
    <EntityPysisEnrichmentDialog
      v-if="entity"
      :entity-id="entity.id"
      :entity-name="entity.name"
      v-model:show-dialog="showEnrichFromPysisDialog"
      v-model:overwrite="enrichPysisOverwrite"
      @enrichment-completed="onPysisEnrichmentCompleted"
    />

    <!-- Source Details Dialog -->
    <SourceDetailsDialog
      v-model="sourceDetailsDialog"
      :source-facet="selectedSourceFacet"
    />

    <!-- Notes Dialog -->
    <EntityNotesDialog
      v-model="notesDialog"
      :notes="notes"
      :new-note="newNote"
      :saving-note="savingNote"
      @update:new-note="newNote = $event"
      @save-note="saveNote"
      @delete-note="deleteNote"
    />

    <!-- Facet Enrichment Review Modal -->
    <FacetEnrichmentReview
      v-model="showEnrichmentReviewDialog"
      :task-id="enrichmentTaskId"
      :task-status="enrichmentTaskStatus"
      :preview-data="enrichmentPreviewData"
      @close="onEnrichmentReviewClose"
      @minimize="onEnrichmentReviewMinimize"
      @applied="onEnrichmentApplied"
    />

    <!-- Minimized Task Toast/Snackbar -->
    <v-snackbar
      v-model="showMinimizedTaskSnackbar"
      :timeout="-1"
      color="info"
      location="bottom end"
    >
      <div class="d-flex align-center" @click="reopenEnrichmentReview" style="cursor: pointer">
        <v-icon class="mr-2">mdi-cog-sync</v-icon>
        {{ t('facetEnrichment.taskMinimized') }}
        <v-btn variant="text" size="small" class="ml-2">
          {{ t('facetEnrichment.clickToReturn') }}
        </v-btn>
      </div>
    </v-snackbar>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useI18n } from 'vue-i18n'
import { useEntityStore, type FacetValue, type Entity, type EntityType } from '@/stores/entity'
import { adminApi, entityApi, facetApi, aiTasksApi, entityDataApi, attachmentApi, relationApi } from '@/services/api'
// date-fns imports (format, formatDistanceToNow, de locale) moved to EntityFacetsTab.vue
import { useSnackbar } from '@/composables/useSnackbar'
import { useFeatureFlags } from '@/composables/useFeatureFlags'
import {
  buildTextRepresentation,
  getStructuredDescription,
  getStructuredType,
  getStructuredSeverity,
  escapeCSV,
  downloadFile,
  getCachedData,
  setCachedData,
  clearCachedData,
} from '@/composables/useEntityDetailHelpers'
import PySisTab from '@/components/PySisTab.vue'
import FacetEnrichmentReview from '@/components/FacetEnrichmentReview.vue'
import DynamicSchemaForm from '@/components/DynamicSchemaForm.vue'
import EntityAttachmentsTab from '@/components/entity/EntityAttachmentsTab.vue'
import EntityDetailHeader from '@/components/entity/EntityDetailHeader.vue'
import EntityConnectionsTab from '@/components/entity/EntityConnectionsTab.vue'
import EntitySourcesTab from '@/components/entity/EntitySourcesTab.vue'
import EntityApiDataTab from '@/components/entity/EntityApiDataTab.vue'
import EntityNotesDialog from '@/components/entity/EntityNotesDialog.vue'
import EntityExportDialog from '@/components/entity/EntityExportDialog.vue'
import EntityDocumentsTab from '@/components/entity/EntityDocumentsTab.vue'
import EntityFacetsTab from '@/components/entity/EntityFacetsTab.vue'
import EntityEditDialog from '@/components/entity/EntityEditDialog.vue'
import ConfirmDialog from '@/components/common/ConfirmDialog.vue'
import FacetDetailsDialog from '@/components/entity/FacetDetailsDialog.vue'
import AddFacetDialog from '@/components/entity/AddFacetDialog.vue'
import AddRelationDialog from '@/components/entity/AddRelationDialog.vue'
import LinkDataSourceDialog from '@/components/entity/LinkDataSourceDialog.vue'
import SourceDetailsDialog from '@/components/entity/SourceDetailsDialog.vue'
import EntityPysisEnrichmentDialog from '@/components/entity/EntityPysisEnrichmentDialog.vue'
import EntityDataSourceManager from '@/components/entity/EntityDataSourceManager.vue'

const { t } = useI18n()
const { flags } = useFeatureFlags()

// ============================================================================
// Local Types
// ============================================================================

interface FacetGroup {
  facet_type_id: string
  facet_type_slug: string
  facet_type_name: string
  facet_type_icon: string
  facet_type_color: string
  facet_type_value_type?: string
  value_count: number
  verified_count: number
  sample_values: FacetValue[]
}

interface FacetsSummary {
  total_facet_values: number
  verified_count: number
  facets_by_type: FacetGroup[]
}

interface Relation {
  id: string
  relation_type_id: string
  source_entity_id: string
  source_entity_name: string
  source_entity_slug: string
  source_entity_type_slug: string
  target_entity_id: string
  target_entity_name: string
  target_entity_slug: string
  target_entity_type_slug: string
  relation_type_name: string
  relation_type_name_inverse: string | null
  relation_type_color: string | null
  attributes: Record<string, any>
  human_verified: boolean
}

interface DataSource {
  id: string
  name: string
  base_url: string
  status: string
  source_type?: string
  is_direct_link?: boolean
  document_count?: number
  last_crawl?: string
  hasRunningJob?: boolean
}

interface Note {
  id: string
  content: string
  author: string
  created_at: string
}

const { showSuccess, showError } = useSnackbar()
const route = useRoute()
const router = useRouter()
const store = useEntityStore()

// Route params - support both /entities/:typeSlug/:entitySlug and /entity/:id
const typeSlug = computed(() => route.params.typeSlug as string | undefined)
const entitySlug = computed(() => route.params.entitySlug as string | undefined)
const entityId = computed(() => route.params.id as string | undefined)

// State
const loading = ref(true)
const activeTab = ref('facets')
const expandedFacets = ref<string[]>([])

// Entity data
const entity = computed<Entity | null>(() => store.selectedEntity)
const entityType = computed<EntityType | null>(() => store.selectedEntityType)
const facetsSummary = ref<FacetsSummary | null>(null)
const relations = ref<Relation[]>([])
const dataSources = ref<DataSource[]>([])
const documents = ref<any[]>([])
const externalData = ref<any>(null)
const attachmentCount = ref(0)

// Children (Untergeordnete Entities) state
const children = ref<Entity[]>([])
const childrenCount = ref(0)
const childrenPage = ref(1)
const childrenTotalPages = ref(1)
const childrenSearchQuery = ref('')
const loadingChildren = ref(false)
const childrenLoaded = ref(false)

// Loading states
const loadingDataSources = ref(false)
const loadingDocuments = ref(false)
const startingCrawl = ref<string | null>(null)

// Data Source Management State
const linkDataSourceDialog = ref(false)
const editSourceDialog = ref(false)
const deleteSourceConfirm = ref(false)
const unlinkSourceConfirm = ref(false)
const selectedSourceToLink = ref<any>(null)
const availableSourcesForLink = ref<any[]>([])
const searchingSourcesForLink = ref(false)
const sourceSearchQuery = ref('')
const editingSource = ref<any>(null)
const sourceToDelete = ref<any>(null)
const sourceToUnlink = ref<any>(null)
const linkingSource = ref(false)

// Dialogs
const addFacetDialog = ref(false)
const addRelationDialog = ref(false)
const facetDetailsDialog = ref(false)
const editDialog = ref(false)
const selectedFacetGroup = ref<any>(null)
const facetDetails = ref<any[]>([])

// Forms
const newFacet = ref({
  facet_type_id: '',
  text_representation: '',
  source_url: '',
  confidence_score: 0.8,
  value: {} as Record<string, any>,
})

// Relation CRUD State
const relationTypes = ref<any[]>([])
const loadingRelationTypes = ref(false)
const editingRelation = ref<Relation | null>(null)
const newRelation = ref({
  relation_type_id: '',
  target_entity_id: '',
  direction: 'outgoing' as 'outgoing' | 'incoming',
  attributes_json: '',
})
const targetEntities = ref<any[]>([])
const searchingEntities = ref(false)
const entitySearchQuery = ref('')
const savingRelation = ref(false)
const deleteRelationConfirm = ref(false)
const relationToDelete = ref<Relation | null>(null)
const deletingRelation = ref(false)

const editForm = ref({
  name: '',
  external_id: '',
})

const savingFacet = ref(false)
const savingEntity = ref(false)

// Facet Search & Expanded State moved to EntityFacetsTab.vue
// Bulk Mode moved to EntityFacetsTab.vue

// Single Facet Edit/Delete (still used by dialogs in EntityDetailView)
const singleDeleteConfirm = ref(false)
const deletingFacet = ref(false)
const facetToDelete = ref<any>(null)
const editFacetDialog = ref(false)
const editingFacet = ref<any>(null)
const editingFacetValue = ref<Record<string, any>>({})
const editingFacetTextValue = ref('')
const editingFacetSchema = ref<any>(null)

// Source Details
const sourceDetailsDialog = ref(false)
const selectedSourceFacet = ref<any>(null)

// Export
const exportDialog = ref(false)
const exportFormat = ref('csv')
const exportOptions = ref({
  facets: true,
  relations: true,
  dataSources: false,
  notes: false,
})
const exporting = ref(false)

// Notes
const notesDialog = ref(false)
const notes = ref<Note[]>([])
const newNote = ref('')
const savingNote = ref(false)

// Relations Lazy Loading
const loadingRelations = ref(false)
const relationsLoaded = ref(false)

// PySis-Facets Enrichment (dialog state)
const hasPysisProcesses = ref(false)
const showEnrichFromPysisDialog = ref(false)
const enrichPysisOverwrite = ref(false)

// New Enrichment System state moved to EntityFacetsTab.vue

// Enrichment Review Modal (still used for task polling and review dialog)
const showEnrichmentReviewDialog = ref(false)
const enrichmentTaskId = ref<string | null>(null)
const enrichmentTaskPolling = ref<ReturnType<typeof setInterval> | null>(null)
const enrichmentTaskStatus = ref<{
  status: string
  progress_current?: number
  progress_total?: number
  current_item?: string
  error_message?: string
} | null>(null)
const enrichmentPreviewData = ref<{
  new_facets?: any[]
  updates?: any[]
  analysis_summary?: any
} | null>(null)
const showMinimizedTaskSnackbar = ref(false)

// Computed
const breadcrumbs = computed(() => {
  // Use typeSlug from route or fallback to entityType.slug
  const slug = typeSlug.value || entityType.value?.slug
  return [
    { title: t('nav.dashboard'), to: '/' },
    { title: entityType.value?.name_plural || t('nav.entities'), to: slug ? `/entities/${slug}` : '/entities' },
    { title: entity.value?.name || '...', disabled: true },
  ]
})

/// Total connections count: relations + children + parent
const totalConnectionsCount = computed(() => {
  const relationCount = entity.value?.relation_count || 0
  // Use children_count from API response (always available), fall back to loaded childrenCount
  const childCount = entity.value?.children_count || childrenCount.value || 0
  const hasParent = entity.value?.parent_id ? 1 : 0
  return relationCount + childCount + hasParent
})

// Filter facet types applicable to current entity type
const applicableFacetTypes = computed(() => {
  const entityTypeSlug = entityType.value?.slug
  if (!entityTypeSlug) return store.activeFacetTypes

  return store.activeFacetTypes.filter(ft => {
    // If no applicable types specified, facet applies to all entity types
    if (!ft.applicable_entity_type_slugs || ft.applicable_entity_type_slugs.length === 0) {
      return true
    }
    // Otherwise check if current entity type is in the list
    return ft.applicable_entity_type_slugs.includes(entityTypeSlug)
  })
})

// Get the selected facet type for the form
const selectedFacetTypeForForm = computed(() => {
  if (!newFacet.value.facet_type_id) return null
  return store.facetTypes.find(ft => ft.id === newFacet.value.facet_type_id)
})

// Methods
async function loadEntityData() {
  loading.value = true
  try {
    // Support both route formats: /entities/:typeSlug/:entitySlug and /entity/:id
    if (entityId.value) {
      // Direct ID access - load entity first, then get entity type
      await store.fetchEntity(entityId.value)
      if (entity.value?.entity_type_id) {
        await store.fetchEntityType(entity.value.entity_type_id)
      }
    } else if (typeSlug.value && entitySlug.value) {
      // Traditional slug-based access
      await store.fetchEntityTypeBySlug(typeSlug.value)
      await store.fetchEntityBySlug(typeSlug.value, entitySlug.value)
    } else {
      showError(t('entityDetail.messages.entityNotFound'))
      router.push('/entities')
      return
    }

    if (!entity.value) {
      showError(t('entityDetail.messages.entityNotFound'))
      router.push(typeSlug.value ? `/entities/${typeSlug.value}` : '/entities')
      return
    }

    // Load facet types if not loaded
    if (store.facetTypes.length === 0) {
      await store.fetchFacetTypes()
    }

    // Load facets summary
    facetsSummary.value = await store.fetchEntityFacetsSummary(entity.value.id)

    // Expand first facet group by default
    if (facetsSummary.value?.facets_by_type?.length) {
      expandedFacets.value = [facetsSummary.value.facets_by_type[0].facet_type_slug]
    }

    // Load notes (from localStorage for now)
    await loadNotes()

    // Reset lazy loading flags
    relationsLoaded.value = false
    // expandedFacetValues now managed by EntityFacetsTab.vue

    // Populate edit form
    editForm.value = {
      name: entity.value.name,
      external_id: entity.value.external_id || '',
    }

    // Check if entity has PySis processes (for municipalities)
    await checkPysisProcesses()

    // Load external API data (non-blocking)
    loadExternalData()

    // Load attachment count (non-blocking)
    loadAttachmentCount()

    // If connections tab is active, load children
    if (activeTab.value === 'connections') {
      loadChildren()
    }
  } catch (e) {
    console.error('Failed to load entity', e)
    showError(t('entityDetail.messages.loadError'))
  } finally {
    loading.value = false
  }
}

async function loadExternalData() {
  if (!entity.value) return
  try {
    const response = await entityApi.getEntityExternalData(entity.value.id)
    externalData.value = response.data
  } catch (e) {
    console.error('Failed to load external data', e)
    externalData.value = null
    showError(t('entityDetail.messages.externalDataLoadError'))
  }
}

async function loadRelations() {
  if (!entity.value || relationsLoaded.value) return

  // Check cache first
  const cacheKey = `relations_${entity.value.id}`
  const cached = getCachedData(cacheKey)
  if (cached) {
    relations.value = cached
    relationsLoaded.value = true
    return
  }

  loadingRelations.value = true
  try {
    const result = await store.fetchEntityRelations({
      entity_id: entity.value.id,
    })
    relations.value = result.items || []
    relationsLoaded.value = true

    // Cache the result
    setCachedData(cacheKey, relations.value)
  } catch (e) {
    console.error('Failed to load relations', e)
    showError(t('entityDetail.messages.relationsLoadError'))
  } finally {
    loadingRelations.value = false
  }
}

// Facet display & search functions moved to EntityFacetsTab.vue
// Bulk actions moved to EntityFacetsTab.vue

// =============================================================================
// EXPORT FUNCTIONS
// =============================================================================

async function exportData() {
  if (!entity.value) return
  exporting.value = true

  try {
    const data: any = {
      entity: {
        id: entity.value.id,
        name: entity.value.name,
        type: entityType.value?.name,
        external_id: entity.value.external_id,
        attributes: entity.value.core_attributes,
      },
    }

    // Collect selected data
    if (exportOptions.value.facets && facetsSummary.value?.facets_by_type) {
      data.facets = {}
      for (const group of facetsSummary.value.facets_by_type) {
        // Load all facets for this type
        const response = await facetApi.getFacetValues({
          entity_id: entity.value.id,
          facet_type_slug: group.facet_type_slug,
          per_page: 10000,
        })
        data.facets[group.facet_type_name] = (response.data.items || []).map((f: any) => ({
          value: f.text_representation || getStructuredDescription(f),
          type: getStructuredType(f),
          severity: getStructuredSeverity(f),
          verified: f.human_verified,
          confidence: f.confidence_score,
          source_url: f.source_url,
        }))
      }
    }

    if (exportOptions.value.relations) {
      data.relations = relations.value.map(r => ({
        type: r.relation_type_name,
        target: r.source_entity_id === entity.value?.id ? r.target_entity_name : r.source_entity_name,
        verified: r.human_verified,
      }))
    }

    if (exportOptions.value.dataSources) {
      data.dataSources = dataSources.value.map(s => ({
        name: s.name,
        url: s.base_url,
        status: s.status,
      }))
    }

    if (exportOptions.value.notes) {
      data.notes = notes.value.map(n => ({
        content: n.content,
        author: n.author,
        date: n.created_at,
      }))
    }

    // Generate export file
    if (exportFormat.value === 'json') {
      downloadFile(
        JSON.stringify(data, null, 2),
        `${entity.value.name}_export.json`,
        'application/json'
      )
    } else if (exportFormat.value === 'csv') {
      const csv = generateCSV(data)
      downloadFile(csv, `${entity.value.name}_export.csv`, 'text/csv')
    } else if (exportFormat.value === 'pdf') {
      // For PDF, we'd need a library like jsPDF or generate on backend
      // For now, show message
      showError(t('entityDetail.messages.pdfNotAvailable'))
      exporting.value = false
      return
    }

    showSuccess(t('entityDetail.messages.exportSuccess'))
    exportDialog.value = false
  } catch (e) {
    console.error('Export failed', e)
    showError(t('entityDetail.messages.exportError'))
  } finally {
    exporting.value = false
  }
}

function generateCSV(data: any): string {
  const lines: string[] = []

  // Entity info
  lines.push(`# ${t('entityDetail.csv.entityInformation')}`)
  lines.push(`${t('entityDetail.csv.name')},${escapeCSV(data.entity.name)}`)
  lines.push(`${t('entityDetail.csv.type')},${escapeCSV(data.entity.type || '')}`)
  lines.push(`${t('entityDetail.csv.externalId')},${escapeCSV(data.entity.external_id || '')}`)
  lines.push('')

  // Facets
  if (data.facets) {
    for (const [typeName, facets] of Object.entries(data.facets)) {
      lines.push(`# ${typeName}`)
      lines.push(`${t('entityDetail.csv.value')},${t('entityDetail.csv.type')},${t('entityDetail.csv.severity')},${t('entityDetail.csv.verified')},${t('entityDetail.csv.confidence')}`)
      for (const f of facets as any[]) {
        lines.push([
          escapeCSV(f.value || ''),
          escapeCSV(f.type || ''),
          escapeCSV(f.severity || ''),
          f.verified ? t('common.yes') : t('common.no'),
          f.confidence ? `${Math.round(f.confidence * 100)}%` : '',
        ].join(','))
      }
      lines.push('')
    }
  }

  // Relations
  if (data.relations?.length) {
    lines.push(`# ${t('entityDetail.csv.relations')}`)
    lines.push(`${t('entityDetail.csv.type')},${t('entityDetail.csv.target')},${t('entityDetail.csv.verified')}`)
    for (const r of data.relations) {
      lines.push([
        escapeCSV(r.type),
        escapeCSV(r.target),
        r.verified ? t('common.yes') : t('common.no'),
      ].join(','))
    }
    lines.push('')
  }

  // Notes
  if (data.notes?.length) {
    lines.push(`# ${t('entityDetail.csv.notes')}`)
    lines.push(`${t('entityDetail.csv.date')},${t('entityDetail.csv.author')},${t('entityDetail.csv.content')}`)
    for (const n of data.notes) {
      lines.push([
        escapeCSV(n.date || ''),
        escapeCSV(n.author || ''),
        escapeCSV(n.content || ''),
      ].join(','))
    }
  }

  return lines.join('\n')
}

// =============================================================================
// NOTES FUNCTIONS
// =============================================================================

async function loadNotes() {
  if (!entity.value) return
  try {
    // Notes are stored as a special facet type or in a separate endpoint
    // For now, we'll store them in localStorage as a simple solution
    const key = `entity_notes_${entity.value.id}`
    const stored = localStorage.getItem(key)
    notes.value = stored ? JSON.parse(stored) : []
  } catch (e) {
    console.error('Failed to load notes', e)
    notes.value = []
  }
}

async function saveNote() {
  if (!entity.value || !newNote.value.trim()) return
  savingNote.value = true

  try {
    const note = {
      id: crypto.randomUUID(),
      content: newNote.value.trim(),
      author: t('entityDetail.currentUser'), // Would come from auth
      created_at: new Date().toISOString(),
    }

    notes.value.unshift(note)

    // Save to localStorage (would be API in production)
    const key = `entity_notes_${entity.value.id}`
    localStorage.setItem(key, JSON.stringify(notes.value))

    newNote.value = ''
    showSuccess(t('entityDetail.messages.noteSaved'))
  } catch (e) {
    showError(t('entityDetail.messages.noteSaveError'))
  } finally {
    savingNote.value = false
  }
}

async function deleteNote(noteId: string) {
  if (!entity.value) return

  try {
    notes.value = notes.value.filter(n => n.id !== noteId)

    // Save to localStorage
    const key = `entity_notes_${entity.value.id}`
    localStorage.setItem(key, JSON.stringify(notes.value))

    showSuccess(t('entityDetail.messages.noteDeleted'))
  } catch (e) {
    showError(t('entityDetail.messages.noteDeleteError'))
  }
}

async function loadDataSources() {
  if (!entity.value) return

  // Check cache first
  const cacheKey = `datasources_${entity.value.id}`
  const cached = getCachedData(cacheKey)
  if (cached) {
    dataSources.value = cached
    return
  }

  loadingDataSources.value = true
  try {
    // Get sources via the new traceability endpoint:
    // Entity -> FacetValues -> Documents -> DataSources
    const response = await entityApi.getEntitySources(entity.value.id)
    dataSources.value = response.data.sources || []

    // Cache the result
    setCachedData(cacheKey, dataSources.value)
  } catch (e) {
    console.error('Failed to load data sources', e)
    dataSources.value = []
    showError(t('entityDetail.messages.dataSourcesLoadError'))
  } finally {
    loadingDataSources.value = false
  }
}

async function loadDocuments() {
  if (!entity.value) return
  loadingDocuments.value = true
  try {
    // Get documents via the traceability endpoint:
    // Entity -> FacetValues -> Documents
    const response = await entityApi.getEntityDocuments(entity.value.id)
    documents.value = response.data.documents || []
  } catch (e) {
    console.error('Failed to load documents', e)
    documents.value = []
    showError(t('entityDetail.messages.documentsLoadError'))
  } finally {
    loadingDocuments.value = false
  }
}

async function loadAttachmentCount() {
  if (!entity.value) return
  try {
    const response = await attachmentApi.list(entity.value.id)
    attachmentCount.value = response.data.total || 0
  } catch (e) {
    console.error('Failed to load attachment count', e)
    attachmentCount.value = 0
  }
}

// ============================================================================
// Data Source Management Functions
// ============================================================================

let sourceSearchTimeout: ReturnType<typeof setTimeout> | null = null

async function searchSourcesForLink(query: string) {
  sourceSearchQuery.value = query
  if (!query || query.length < 2) {
    availableSourcesForLink.value = []
    return
  }

  if (sourceSearchTimeout) clearTimeout(sourceSearchTimeout)
  sourceSearchTimeout = setTimeout(async () => {
    searchingSourcesForLink.value = true
    try {
      const response = await adminApi.getSources({ search: query, per_page: 20 })
      // Filter out already linked sources
      const linkedIds = new Set(dataSources.value.map((s: any) => s.id))
      availableSourcesForLink.value = (response.data.items || []).filter(
        (s: any) => !linkedIds.has(s.id)
      )
    } catch (e) {
      console.error('Failed to search sources:', e)
      availableSourcesForLink.value = []
      showError(t('entityDetail.messages.sourceSearchError'))
    } finally {
      searchingSourcesForLink.value = false
    }
  }, 300)
}

async function linkSourceToEntity() {
  if (!selectedSourceToLink.value || !entity.value) return

  linkingSource.value = true
  try {
    // Update the source's extra_data to add this entity to entity_ids (N:M)
    const sourceId = selectedSourceToLink.value.id
    const currentExtraData = selectedSourceToLink.value.extra_data || {}

    // Support legacy entity_id and new entity_ids array
    const existingEntityIds = currentExtraData.entity_ids ||
      (currentExtraData.entity_id ? [currentExtraData.entity_id] : [])

    // Add new entity if not already linked
    const newEntityIds = existingEntityIds.includes(entity.value.id)
      ? existingEntityIds
      : [...existingEntityIds, entity.value.id]

    await adminApi.updateSource(sourceId, {
      extra_data: {
        ...currentExtraData,
        entity_ids: newEntityIds,
        // Remove legacy field
        entity_id: undefined,
      },
    })

    showSuccess(t('entityDetail.messages.sourceLinkSuccess'))
    linkDataSourceDialog.value = false
    selectedSourceToLink.value = null

    // Invalidate cache and reload
    clearCachedData(`datasources_${entity.value.id}`)
    await loadDataSources()
  } catch (e) {
    console.error('Failed to link source:', e)
    showError(t('entityDetail.messages.sourceLinkError'))
  } finally {
    linkingSource.value = false
  }
}

function openEditSourceDialog(source: any) {
  editingSource.value = source
  editSourceDialog.value = true
}

function confirmDeleteSource(source: any) {
  sourceToDelete.value = source
  deleteSourceConfirm.value = true
}

function confirmUnlinkSource(source: any) {
  sourceToUnlink.value = source
  unlinkSourceConfirm.value = true
}

// Handler functions for EntityDataSourceManager events
async function onSourceUpdated() {
  // Invalidate cache and reload
  if (entity.value) {
    clearCachedData(`datasources_${entity.value.id}`)
  }
  await loadDataSources()
}

async function onSourceDeleted() {
  sourceToDelete.value = null
  // Invalidate cache and reload
  if (entity.value) {
    clearCachedData(`datasources_${entity.value.id}`)
  }
  await loadDataSources()
}

async function onSourceUnlinked() {
  sourceToUnlink.value = null
  // Invalidate cache and reload
  if (entity.value) {
    clearCachedData(`datasources_${entity.value.id}`)
  }
  await loadDataSources()
}

function goToSourcesWithEntity() {
  if (!entity.value) return
  // Navigate to sources page with entity pre-selected
  router.push({
    name: 'sources',
    query: { linkEntity: entity.value.id },
  })
}

// Children (Untergeordnete Entities) functions
async function loadChildren() {
  if (!entity.value) return

  loadingChildren.value = true
  try {
    const response = await entityApi.getEntityChildren(entity.value.id, {
      page: childrenPage.value,
      per_page: 20,
    })
    children.value = response.data.items || []
    childrenCount.value = response.data.total || 0
    childrenTotalPages.value = response.data.pages || 1
    childrenLoaded.value = true
  } catch (e) {
    console.error('Failed to load children', e)
    children.value = []
    childrenCount.value = 0
    showError(t('entityDetail.children.loadError'))
  } finally {
    loadingChildren.value = false
  }
}

// toggleFacetExpand moved to EntityFacetsTab.vue

async function openFacetDetails(facetGroup: any) {
  selectedFacetGroup.value = facetGroup
  facetDetailsDialog.value = true

  try {
    const response = await facetApi.getFacetValues({
      entity_id: entity.value?.id,
      facet_type_slug: facetGroup.facet_type_slug,
      per_page: 10000,
    })
    facetDetails.value = response.data.items || []
  } catch (e) {
    console.error('Failed to load facet details', e)
    facetDetails.value = []
    showError(t('entityDetail.messages.facetDetailsLoadError'))
  }
}

// Handle facet type change in the add dialog
function onFacetTypeChange() {
  // Reset the value when facet type changes
  newFacet.value.value = {}
  newFacet.value.text_representation = ''
}

// Close the add facet dialog and reset form
function closeAddFacetDialog() {
  addFacetDialog.value = false
  resetAddFacetForm()
}

// Open add facet value dialog with pre-selected facet type
function openAddFacetValueDialog(facetGroup: any) {
  resetAddFacetForm()
  // Pre-select the facet type from the group
  newFacet.value.facet_type_id = facetGroup.facet_type_id
  addFacetDialog.value = true
}

// Reset the add facet form
function resetAddFacetForm() {
  newFacet.value = {
    facet_type_id: '',
    text_representation: '',
    source_url: '',
    confidence_score: 0.8,
    value: {},
  }
}

async function saveFacetValue() {
  if (!newFacet.value.facet_type_id) return
  if (!entity.value) return

  const facetType = selectedFacetTypeForForm.value
  if (!facetType) return

  // Determine value and text representation based on facet type
  let valueToSave: Record<string, any>
  let textRepresentation: string

  if (facetType.value_schema?.properties) {
    // Structured facet - use the dynamic form value
    valueToSave = { ...newFacet.value.value }
    textRepresentation = buildTextRepresentation(valueToSave, facetType)
  } else {
    // Simple text facet
    if (!newFacet.value.text_representation) return
    valueToSave = { text: newFacet.value.text_representation }
    textRepresentation = newFacet.value.text_representation
  }

  if (!textRepresentation) {
    showError(t('entityDetail.messages.facetValueRequired'))
    return
  }

  savingFacet.value = true
  try {
    await facetApi.createFacetValue({
      entity_id: entity.value.id,
      facet_type_id: newFacet.value.facet_type_id,
      value: valueToSave,
      text_representation: textRepresentation,
      source_url: newFacet.value.source_url || null,
      confidence_score: newFacet.value.confidence_score,
    })

    showSuccess(t('entityDetail.messages.facetAdded'))
    closeAddFacetDialog()

    // Reload facets summary
    facetsSummary.value = await store.fetchEntityFacetsSummary(entity.value.id)
    // expandedFacetValues now managed by EntityFacetsTab.vue
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.facetSaveError'))
  } finally {
    savingFacet.value = false
  }
}

async function verifyFacet(facetValueId: string) {
  try {
    await store.verifyFacetValue(facetValueId, true)
    showSuccess(t('entityDetail.messages.facetVerified'))
    // Reload details
    if (selectedFacetGroup.value) {
      await openFacetDetails(selectedFacetGroup.value)
    }
    // Reload summary
    if (entity.value) {
      facetsSummary.value = await store.fetchEntityFacetsSummary(entity.value.id)
    }
  } catch (e) {
    showError(t('entityDetail.messages.verifyError'))
  }
}

/**
 * Refresh the facets summary - called by child components when facet data changes
 */
async function refreshFacetsSummary() {
  if (entity.value) {
    facetsSummary.value = await store.fetchEntityFacetsSummary(entity.value.id)
  }
}

// openSourceDetails, openEditFacetDialog moved to EntityFacetsTab.vue

// Save edited facet
async function saveEditedFacet() {
  if (!editingFacet.value) return

  savingFacet.value = true
  try {
    const updateData = {
      value: editingFacetSchema.value ? editingFacetValue.value : { text: editingFacetTextValue.value },
      text_representation: editingFacetSchema.value
        ? Object.values(editingFacetValue.value).filter(v => v).join(' - ').substring(0, 500)
        : editingFacetTextValue.value,
    }
    await facetApi.updateFacetValue(editingFacet.value.id, updateData)
    showSuccess(t('entityDetail.messages.facetUpdated'))
    editFacetDialog.value = false
    // Reload facet details
    if (selectedFacetGroup.value) {
      await openFacetDetails(selectedFacetGroup.value)
    }
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.facetSaveError'))
  } finally {
    savingFacet.value = false
  }
}

// confirmDeleteFacet moved to EntityFacetsTab.vue

// Delete single facet
async function deleteSingleFacet() {
  if (!facetToDelete.value) return

  deletingFacet.value = true
  try {
    await facetApi.deleteFacetValue(facetToDelete.value.id)
    showSuccess(t('entityDetail.messages.facetDeleted'))
    singleDeleteConfirm.value = false
    facetToDelete.value = null
    // Reload facet details
    if (selectedFacetGroup.value) {
      await openFacetDetails(selectedFacetGroup.value)
    }
    // Reload summary
    if (entity.value) {
      facetsSummary.value = await store.fetchEntityFacetsSummary(entity.value.id)
    }
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.deleteError'))
  } finally {
    deletingFacet.value = false
  }
}

// =============================================================================
// Relation CRUD Functions
// =============================================================================

async function loadRelationTypes() {
  if (relationTypes.value.length > 0) return // Already loaded

  loadingRelationTypes.value = true
  try {
    const response = await relationApi.getRelationTypes()
    relationTypes.value = response.data.items || response.data || []
  } catch (e) {
    console.error('Failed to load relation types', e)
    showError(t('entityDetail.messages.relationTypesLoadError'))
  } finally {
    loadingRelationTypes.value = false
  }
}

async function searchEntities(query: string) {
  if (!query || query.length < 2) {
    targetEntities.value = []
    return
  }

  searchingEntities.value = true
  try {
    const response = await entityApi.searchEntities({ q: query, per_page: 20 })
    // Filter out the current entity from results
    targetEntities.value = (response.data.items || []).filter(
      (e: any) => e.id !== entity.value?.id
    )
  } catch (e) {
    console.error('Failed to search entities', e)
    targetEntities.value = []
    showError(t('entityDetail.messages.entitySearchError'))
  } finally {
    searchingEntities.value = false
  }
}

function openAddRelationDialog() {
  editingRelation.value = null
  newRelation.value = {
    relation_type_id: '',
    target_entity_id: '',
    direction: 'outgoing',
    attributes_json: '',
  }
  targetEntities.value = []
  entitySearchQuery.value = ''
  addRelationDialog.value = true
  loadRelationTypes()
}

function editRelation(rel: Relation) {
  editingRelation.value = rel
  // Determine direction based on whether current entity is source or target
  const isSource = rel.source_entity_id === entity.value?.id
  newRelation.value = {
    relation_type_id: rel.relation_type_id || '',
    target_entity_id: isSource ? rel.target_entity_id : rel.source_entity_id,
    direction: isSource ? 'outgoing' : 'incoming',
    attributes_json: rel.attributes ? JSON.stringify(rel.attributes, null, 2) : '',
  }
  // Pre-populate the target entities list with the current target
  targetEntities.value = [{
    id: isSource ? rel.target_entity_id : rel.source_entity_id,
    name: isSource ? rel.target_entity_name : rel.source_entity_name,
    entity_type_name: isSource ? rel.target_entity_type_slug : rel.source_entity_type_slug,
  }]
  addRelationDialog.value = true
  loadRelationTypes()
}

function closeRelationDialog() {
  addRelationDialog.value = false
  editingRelation.value = null
  newRelation.value = {
    relation_type_id: '',
    target_entity_id: '',
    direction: 'outgoing',
    attributes_json: '',
  }
}

async function saveRelation() {
  if (!entity.value || !newRelation.value.relation_type_id || !newRelation.value.target_entity_id) {
    return
  }

  savingRelation.value = true
  try {
    // Parse attributes JSON if provided
    let attributes = {}
    if (newRelation.value.attributes_json.trim()) {
      try {
        attributes = JSON.parse(newRelation.value.attributes_json)
      } catch (e) {
        showError(t('entityDetail.messages.invalidJson'))
        savingRelation.value = false
        return
      }
    }

    // Determine source and target based on direction
    const sourceId = newRelation.value.direction === 'outgoing'
      ? entity.value.id
      : newRelation.value.target_entity_id
    const targetId = newRelation.value.direction === 'outgoing'
      ? newRelation.value.target_entity_id
      : entity.value.id

    const data = {
      relation_type_id: newRelation.value.relation_type_id,
      source_entity_id: sourceId,
      target_entity_id: targetId,
      attributes: Object.keys(attributes).length > 0 ? attributes : null,
    }

    if (editingRelation.value) {
      await relationApi.updateRelation(editingRelation.value.id, data)
      showSuccess(t('entityDetail.messages.relationUpdated'))
    } else {
      await relationApi.createRelation(data)
      showSuccess(t('entityDetail.messages.relationCreated'))
    }

    closeRelationDialog()
    // Reload relations
    relationsLoaded.value = false
    await loadRelations()
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.relationSaveError'))
  } finally {
    savingRelation.value = false
  }
}

function confirmDeleteRelation(rel: Relation) {
  relationToDelete.value = rel
  deleteRelationConfirm.value = true
}

async function deleteRelation() {
  if (!relationToDelete.value) return

  deletingRelation.value = true
  try {
    await relationApi.deleteRelation(relationToDelete.value.id)
    showSuccess(t('entityDetail.messages.relationDeleted'))
    deleteRelationConfirm.value = false
    relationToDelete.value = null
    // Reload relations
    relationsLoaded.value = false
    await loadRelations()
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.deleteError'))
  } finally {
    deletingRelation.value = false
  }
}

async function saveEntity() {
  if (!entity.value) return

  savingEntity.value = true
  try {
    await store.updateEntity(entity.value.id, {
      name: editForm.value.name,
      external_id: editForm.value.external_id || null,
    })
    showSuccess(t('entityDetail.messages.entityUpdated'))
    editDialog.value = false
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.entitySaveError'))
  } finally {
    savingEntity.value = false
  }
}

async function startCrawl(source: any) {
  startingCrawl.value = source.id
  try {
    await adminApi.startCrawl({ source_ids: [source.id] })
    showSuccess(t('entityDetail.messages.crawlStarted', { name: source.name }))
    source.hasRunningJob = true
  } catch (e: any) {
    showError(e.response?.data?.detail || t('entityDetail.messages.crawlStartError'))
  } finally {
    startingCrawl.value = null
  }
}

function navigateToRelatedEntity(rel: any) {
  const targetId = rel.source_entity_id === entity.value?.id
    ? rel.target_entity_id
    : rel.source_entity_id
  const targetSlug = rel.source_entity_id === entity.value?.id
    ? rel.target_entity_type_slug
    : rel.source_entity_type_slug
  const targetEntitySlug = rel.source_entity_id === entity.value?.id
    ? rel.target_entity_slug || targetId
    : rel.source_entity_slug || targetId

  router.push({
    name: 'entity-detail',
    params: { typeSlug: targetSlug, entitySlug: targetEntitySlug },
  })
}

// Facet helper functions (formatFacetValue, formatDate, getConfidenceColor, etc.) moved to EntityFacetsTab.vue
// Source Type Helpers (normalizeSourceType, getFacetSourceColor, getFacetSourceIcon) moved to EntityFacetsTab.vue
// Structured Facet Value Helpers moved to EntityFacetsTab.vue
// Contact Helpers moved to EntityFacetsTab.vue
// Helper functions moved to useEntityDetailHelpers composable

function copyToClipboard(text: string) {
  navigator.clipboard.writeText(text)
  showSuccess(t('entityDetail.messages.copiedToClipboard'))
}

// =============================================================================
// PYSIS-FACETS ENRICHMENT
// =============================================================================

async function checkPysisProcesses() {
  if (!entity.value || !entityType.value?.supports_pysis) {
    hasPysisProcesses.value = false
    return
  }

  try {
    const { pysisApi } = await import('@/services/api')
    const response = await pysisApi.getProcesses(entity.value.name)
    hasPysisProcesses.value = (response.data.items?.length || 0) > 0
  } catch (e) {
    console.error('Failed to check PySis processes', e)
    hasPysisProcesses.value = false
  }
}

// Handler for PySis enrichment completion
async function onPysisEnrichmentCompleted() {
  // Refresh facets data
  await loadEntityData()
}

// ========================================
// New Enrichment System Functions
// (onEnrichmentMenuOpen, loadEnrichmentSources, formatEnrichmentDate, startEnrichmentAnalysis moved to EntityFacetsTab.vue)
// ========================================

function startEnrichmentTaskPolling(taskId: string) {
  stopEnrichmentTaskPolling()

  enrichmentTaskPolling.value = setInterval(async () => {
    try {
      const response = await aiTasksApi.getStatus(taskId)
      enrichmentTaskStatus.value = response.data

      // Check if task is completed
      if (response.data.status === 'COMPLETED') {
        stopEnrichmentTaskPolling()

        // Fetch the preview data
        try {
          const previewResponse = await entityDataApi.getAnalysisPreview(taskId)
          enrichmentPreviewData.value = previewResponse.data
        } catch (e) {
          console.error('Failed to fetch preview', e)
        }
      } else if (response.data.status === 'FAILED' || response.data.status === 'CANCELLED') {
        stopEnrichmentTaskPolling()
      }
    } catch (e) {
      console.error('Failed to poll task status', e)
    }
  }, 2000)
}

function stopEnrichmentTaskPolling() {
  if (enrichmentTaskPolling.value) {
    clearInterval(enrichmentTaskPolling.value)
    enrichmentTaskPolling.value = null
  }
}

function onEnrichmentReviewClose() {
  stopEnrichmentTaskPolling()
  showMinimizedTaskSnackbar.value = false
  enrichmentTaskId.value = null
  enrichmentTaskStatus.value = null
  enrichmentPreviewData.value = null
}

function onEnrichmentReviewMinimize() {
  showEnrichmentReviewDialog.value = false
  // Show minimized snackbar only if task is still running
  if (enrichmentTaskStatus.value?.status === 'RUNNING' || enrichmentTaskStatus.value?.status === 'PENDING') {
    showMinimizedTaskSnackbar.value = true
  }
}

function reopenEnrichmentReview() {
  showMinimizedTaskSnackbar.value = false
  showEnrichmentReviewDialog.value = true
}

async function onEnrichmentApplied(result: { created: number; updated: number }) {
  showSuccess(t('facetEnrichment.applied', result))
  // Refresh entity data
  await loadEntityData()
}

/**
 * Handle enrichment started event from EntityFacetsTab
 * Opens the enrichment review dialog and starts polling
 */
function onEnrichmentStarted(taskId: string) {
  enrichmentTaskId.value = taskId
  enrichmentTaskStatus.value = { status: 'PENDING' }
  enrichmentPreviewData.value = null
  showEnrichmentReviewDialog.value = true
  showMinimizedTaskSnackbar.value = false
  startEnrichmentTaskPolling(taskId)
}

// Cleanup on unmount
onUnmounted(() => {
  stopEnrichmentTaskPolling()
  // Clear any pending search timeout
  if (sourceSearchTimeout) {
    clearTimeout(sourceSearchTimeout)
    sourceSearchTimeout = null
  }
})

// Watch for tab changes to load data lazily
watch(activeTab, (tab) => {
  if (tab === 'relations' && !relationsLoaded.value) {
    loadRelations()
  }
  if (tab === 'sources' && dataSources.value.length === 0) {
    loadDataSources()
  }
  if (tab === 'documents' && documents.value.length === 0) {
    loadDocuments()
  }
  if (tab === 'connections' && !childrenLoaded.value) {
    loadChildren()
  }
})

// Watch for route changes (both slug-based and ID-based routes)
watch([typeSlug, entitySlug, entityId], () => {
  // Reset state for new entity (facet-related state now managed by EntityFacetsTab.vue)
  // Reset children/relations for new entity
  childrenLoaded.value = false
  children.value = []
  childrenCount.value = 0
  childrenPage.value = 1
  relationsLoaded.value = false
  relations.value = []
  loadEntityData()
})

// Init
onMounted(() => {
  loadEntityData()
})
</script>

<style scoped>
.cursor-pointer {
  cursor: pointer;
}

.facet-item {
  transition: all 0.2s ease;
  border: 2px solid transparent;
}

.facet-item:hover {
  border-color: rgba(var(--v-theme-primary), 0.3);
}

.facet-item.selected {
  border-color: rgb(var(--v-theme-primary));
  background-color: rgba(var(--v-theme-primary), 0.08) !important;
}

.bg-primary-lighten-5 {
  background-color: rgba(var(--v-theme-primary), 0.1);
}

/* Hierarchy Tree Visualization */
.hierarchy-tree {
  text-align: center;
}

.tree-level {
  position: relative;
}

.tree-connector {
  width: 2px;
  background: rgb(var(--v-theme-primary));
  margin: 0 auto;
}

.tree-connector-vertical {
  height: 24px;
}

.tree-connector-down-from-current {
  height: 32px;
}

.tree-node {
  transition: all 0.2s ease;
}

.tree-node:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.tree-node-current {
  border-radius: 12px;
}

.tree-children-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 12px;
  max-width: 1200px;
  margin: 0 auto;
}

.tree-node-child {
  border-radius: 8px;
}

.relations-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 12px;
}

.relation-card {
  border-radius: 8px;
  transition: all 0.2s ease;
}

.relation-card:hover {
  border-color: rgb(var(--v-theme-primary));
  background: rgba(var(--v-theme-primary), 0.04);
}

/* Dark mode adjustments for tree view */
.v-theme--dark .tree-node-child,
.v-theme--dark .tree-node-parent {
  border-color: rgba(255, 255, 255, 0.12);
}

.v-theme--dark .tree-node-child:hover,
.v-theme--dark .tree-node-parent:hover {
  border-color: rgb(var(--v-theme-primary));
  background: rgba(var(--v-theme-primary), 0.08);
}

.v-theme--dark .relation-card {
  border-color: rgba(255, 255, 255, 0.12);
}

.v-theme--dark .relation-card:hover {
  background: rgba(var(--v-theme-primary), 0.08);
}
</style>
